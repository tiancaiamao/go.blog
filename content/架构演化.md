首先，我们有一个简单的web业务节点。

![](./static/single-node.png)

然后，业务请求量越来越大，单个节点性能跟不上，满足不了需要。所以这时我们加一层负载均衡，典型的像使用nginx做反向代理。

![](./static/nginx.png)

业务节点尽量是无状态的，扩展性比较好。但是有时候还是需要有一些控制，所以我们加入中心化的控制节点，控制节点会通知业务节点一些状态变化。

![](./static/control.png)

控制节点的代码写得好烦。相当于是把业务节点的一些状态放到控制结点里面管理了，由它自己去通知各个节点。程序员就是喜欢偷懒，喜欢把麻烦的东西都托管出去。好，我们加一个消息队列。只要抽象出一些channel，然后pub/sub模型，这些麻烦的消息处理就交给开源代码去做吧。只管把消息pub出去，自然就通知到各个业务节点了。有序到达，不丢消息等等，交给开源软件就是各种爽。

![](./static/mq.png)

系统继续变大，发现现在中心结点是有单点问题的。要不搞个主从吧？

![](./static/master-slave.png)

逼格不够高啊，搞个去中心化的？我擦勒...paxos是啥玩意？智商着急，算了。主从之间也有状态同步问题，自己搞代码还是很不爽。要不再偷一下懒，把中心化的状态再托管给开源软件吧。不是有zookeeper，etcd之类的么。

![](./static/chubby.png)

嗯，好了。

学生时代觉得谈架构好牛逼，现在觉得写这些东西都是软文，全部废话。其实愿意写的话，再细到缓存，数据库，都可以这样慢慢“演化”。但是仔细观察就会发现一个特点：图中框框里的东西会比较难，圆圈的东西比较简单，而难的东西，都是交给别人做的。

什么大规模系统，什么高并发，谈什么架构？扯淡。越是看上去复杂的系统，越是简单。不就是拼凑了一下开源轮子吗？