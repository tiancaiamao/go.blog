最近一段时间，我写代码的时候，几乎都会顺手开着一两个 coding agent。

有时候是在跑一个 demo，有时候是丢给它一个完整仓库，让它慢慢改。我自己在旁边干别的事情，隔一会儿切回来看看它现在在干嘛。久而久之，这事儿就有点像是在观察一个不太聪明、但手速很快、而且永远不嫌加班的同事。

慢慢地，我开始不太满足于“哇，这也能写”，而是开始问一个更工程化的问题：

> **现在这个阶段，AI 写代码的能力边界到底在哪里？**

我不是想讨论那种“AI 会不会取代程序员”的宏大命题，那种话题太空了。对我来说，更重要的是一些非常具体的问题：

> 这个任务，我能不能把它交给 AI？
> 
> 如果不能，是哪一步开始搞不定的，为什么？

下面这些例子，都是我这段时间真实跑过的。有成功得让我吃惊的，也有失败得让我意识到“哦，原来边界在这里”。

## 一个几乎满分的例子：C++ 服务器整体转 C

先说一个让我非常震惊的成功案例。

任务本身不复杂，但量也不算小：把一个用 C++ 写的网络服务器 demo，完整改写成 **纯 C 语言实现**。

原项目是这个：https://github.com/yuesong-feng/30dayMakeCppServer

这个用的工具和 AI 是 **kiro + opus 4.5**，需求描述其实也很简单：

> 保留原有行为，把 C++ 的实现完整改成 C

然后我就基本没管它了。过了一会儿切回来看，发现事情已经做完了。更关键的是：不是那种“看起来差不多”，而是真的能用。

具体表现包括：

- C++ 的 class 被完整拆成了 struct + 一组函数
- 构造 / 析构逻辑被显式地翻成 init / free
- socket、epoll、事件循环这些地方完全没乱
- 没有偷偷混进 C++ 语法
- 代码风格甚至还挺干净

我把代码拉下来直接编译，一把过。最终的结果在这里：https://github.com/tiancaiamao/tcp_server/tree/main/src

这件事对我的冲击其实挺大的，因为它几乎是 **0 人工干预**。我只是定义了边界，它就把整个体力活干完了。这类任务我给 98 分，一点不夸张。

后来想一想，其实也能理解它为什么能干得这么好：

- 网络服务器是非常高频的编程模式
- 有完整、清晰的参考实现
- 目标语言（C）和源语言（C++）都极其成熟
- 项目规模不大，但结构完整

在这种条件下，AI 更像是一个极其熟练的“代码搬运 + 重构机器”。

## IDE中的代码补全：已经是基础设施了

大家每天都在用到 IDE、但已经不太会特意讨论的那一类能力。

比如：

- 写到一半的函数补全
- for / if / error handling 的模板
- 常见 API 的调用方式

VS Code、Zed 这些编辑器现在基本都自带 AI 功能了。

对于补全这种场景下，用户的心理预期本身就很低：

> 对了就 tab，不对就当没看见

所以模型只要别太离谱，体验就已经不错了。copilot-nano 之类的小模型，在这里都完全够用。90 分起步。

## 中等复杂度，但反馈完整：ad 编辑器的两个例子

接下来是我觉得**非常有代表性的一类任务**：

> 不只是补全，而是需要读项目、理解上下文、再改代码

我现在的主力编辑器是 fork 了 [ad](https://github.com/sminez/ad) 编辑器这个项目。它不算成熟，时不时有一些问题。好几次让 AI 直接参与真实开发。

### 例子一：实现一个小功能

ad 的键位跟 vim 设计得不太一样，虽然都是模态编辑，但是 ad 更倾向于 Kakoune 编辑器的理念。我平时都是用 vim 键位，所以有些地方会不适应。
其中有一个就是屏幕的滚动的快捷键绑定，在 vim 那边是 ctrl-f ctrl-b ctrl-d ctrl-u ctrl-e 这些。

这样的一个 commit 是 AI 直接完成的：https://github.com/tiancaiamao/ad/commit/8332b513b7ce2c19b86efca8b581de850875b7dd

它需要做的事情包括：

- 理解 ad 这个编辑器的代码结构
- 搞清楚 buffer / window / view 之间的关系
- 在现有设计约束下改代码，而不是乱加东西

这类任务已经明显超过“写几行代码”了，但 AI 还是能完成，原因其实也很清楚：

- 这是一个成熟语言（Go）
- 能直接编译
- 能运行
- 行为对不对，可以立刻验证

### 例子二：帮忙修 bug 和 resolve commet

另一个我觉得更有意思的例子，是这个 PR：https://github.com/sminez/ad/pull/173

背景是这样的：

- 我自己先提了一个非常小的修复（一行代码）
- 作者 review 之后指出：实现思路不太对

于是我干脆把整个 PR 链接丢给 AI，让它：

- 抓 PR 页面
- 读评论里的讨论
- 理解 reviewer 真正想要的行为
- 再回到代码里修

结果是：**它真的能做**。不是一次就完美，但在几轮修改之后，它给出的方案是合理的，而且是“对着 review 意图来的”，不是瞎改。

但它已经能帮我省掉大量“理解上下文 + 尝试实现”的时间了。

## 开始失败的地方：小众语言 + 相对复杂的功能

让我明确意识到能力“边界”的，是我自己的编程语言项目 [cora](https://github.com/tiancaiamao/cora)。这是一个 lisp 的方言，很多基础设施都是我自己写的。

前段时间我在博客里写了一篇[文章](/cora-multicore-support-2.md)，讨论接下来要怎么实现多核并发模型。于是我尝试了一下：

- 把那篇博客描述丢给 AI
- 把代码丢给 AI
- 要求它按照博客里的设计，把并发框架实现出来

一开始，一切看起来都还不错。它能理解博客在讲什么，也能照着改代码，甚至改出来的代码**乍一看很像那么回事**。

但很快问题就暴露出来了。cora 这种小众的东西太不成熟：

- 没有调试器
- 报错信息非常原始
- 有可能直接卡死而不是返回错误
- 出了问题，很多时候只能靠我自己在脑子里跑

这些东西，AI 完全接不上。它习惯的工作方式是：

> 写代码 → 编译 → 看报错 → 再改

而在 cora 这里，这条反馈链路当前是断的，它不知道怎么样去处理。于是它只能不停地产生**看起来合理、但根本没法工作的代码**。然后求助于用户反馈。

## 另一个失败案例：实际工作中跨 TiDB / client-go / TiKV 的小 PR

还有一个失败得非常典型的例子，是这个 TiKV 的 PR：https://github.com/tikv/tikv/pull/19166

这个是工作中的一个例子，比较特别的是这个不在于某一段代码，而在于逻辑横跨 TiDB → client-go → TiKV，多个 repo。改动其实对于人类来说比较简单，就是协议层变化，从上到下改一点点东西。

但是在 AI 在这里的表现是：

- 能看懂“局部”
- 能改某一个点
- 但对全链路还比较困难

你让它在单个 repo 里改一段，它能改；但你让它理解「为什么上游这么设计，下游必须那样实现」，它就开始搞不定了。

## 一个几乎不可能的任务：大型开源游戏

我还试把一个**大型开源游戏项目**直接丢给 AI：https://github.com/opendarkeden/client

这个项目代码量巨大，百万行级别的代码。而且代码质量也不咋滴，依赖特别复杂。它是几十年前的 MMORPG 游戏，编译环境是 windows + DirectX，需要用 vc6 编译器。这样的编译环境，如果根本就不具备了，所以我都没法折腾它。

没有 AI 以前，我想着重写它，但是又不敢动手。因为这种工作量我预估是全职投入一年以上的工作量，所以不敢想。但是有了 AI 之后，这变成了一个可以尝试一下的事情。

第一次尝试，我的做法是先让 AI 帮我从边缘开始搞起，比如解析动画，地图等资源文件的格式，然后用 SDL 渲染出来。然后做个小 demo，加载一个地图，让角色可以在地图中行走。so far so good，这些 AI 都完成得非常漂亮。

然后由于游戏这块比较大，我决定继续从界面那边入手。我让 AI 帮忙移植和重写界面用到的库，到这里都挺好。出 demo 都能做出来，但是一旦到了真实的整合原始的素材资源，还原原始的执行逻辑这一步，就开始不行了。

这个游戏它的依赖写得特别挫，好的做法应该是一层一层抽象，上层不需要了解更下层的细节，比如从 SDL 或者 DirectX 往上层 SpriteLib 的封装，再然后游戏 UI 这边一般是立即模式 UI，再从 Sprite 到 UI 库，再往上具体的某些游戏界面，Dialog 等等处理逻辑。它这个不完全封装，上层还直接引用 DirectDraw 的 API。所以就很丑。

AI 做的时候，从简单 demo 往上这一步，就搞不定了。经常 stub 一个东西，然后还是以偷懒完成我描述的任务，但是不 stub 原始的依赖它有解不了，编译不过。到这里总是要人的介入，就不行了。

第二次我尝试了另一种方式。前一种方式里面，一小块一小块拿出来做个 demo，再慢慢扩大 demo，对于人类来讲相对平滑。但是游戏的内容太多了，从 demo 到还原原始的游戏逻辑的时候，就不行了。相当于要从下往上重写。

现在我换了一种方式，在某一层封装好统一的 API，下层改用不同的实现，封装好的这层，屏蔽掉下层的细节，然后上动的代码尽量不用改动。这个方式不那么平滑，但是有良好反馈，可以让 AI 不停地自己去修 CI，直到修好。它还真做到了！

## 一条非常清晰的分界线：反馈循环

回头看这些成功和失败的例子，我现在觉得真正的分水岭：

> **AI 能不能拿到真实、快速、明确的反馈？**

只要有：

- 编译
- 运行
- 报错
- 测试结果

哪怕任务不算小，AI 都能靠疯狂试错硬推进度。

而一旦：

- 没法运行
- 没法观察状态
- 错误语义不清晰

AI 就会迅速退化成一个“看起来很懂”的文本生成器。

从 Cursor 早期那种人为主，AI 为辅助，到现在 agentic coding，除了 AI 本身智力的提升，一个更重要的变化就是学习工具的使用和得到反馈。AI 作为一个大脑来指挥 agent，agent 来执行各种工具的调用。
当有了这种闭环之后，自动化 coding 的能力感觉突然就被解锁了。再到后面，可以几十分钟，甚至几个小时，不需要人的干预，全自动的完成一件事情。

而且我能够感受到 AI 真的很聪明，举个例子，我在弄游戏 demo 这种，我告诉它哪个按钮按了没反应，它是不太好去反馈的，因为没有工具。它怎么做的？我发现它收到我的反馈后，去代码多少帧，加入 debug，模拟点击那边按钮，再在事件那边加 log 打印，然后去运行程序了观察 log 的情况获取信息。
这真的把我都惊呆了！

当前它能用比如读文件，访问网站，遍历，编译，调用脚本等等很多工具，于是就可以做很多事情。而相对地，调用调试器去调试的这种能力还不是很强。但是一旦它学习好工具的使用之后，能够调用然后得到反馈循环之后，效果就会完全不一样了。可以预见，后面这些东西 AI 肯定都能掌握的。

## 最后一点个人感受

2025 年明显是一个 vibe coding 从概念到落地的过程，而 2026 年的 AI 的 coding 能力会更加强大，程序员将很少再需要用现在的方式去写代码了。

以前写代码，先是设计，然后任务各种拆解，然后一步一步去写，预估一个月的工作量。现在这些，丢给 AI 一天以内搞完了。这将产生巨大的影响。

而且这个过程会来得很快，AI 的进化速度真的恐怖，一个月前的，跟一个月后的，可能都是不同版本的故事。即使今天在能力边界以外的任务，又或者没隔多久，也能搞定了。这是趋势，是真在发生的内容。

我以自己不久前发的一条朋友圈作为结语：从纸带，到汇编，到高级编程语言，再到 ai 问世，vibe coding 从概念到普及 ... 时代的车轮滚滚向前，我们应该是最后一代经历“古法编程”的程序员了。2026 年，见证历史
