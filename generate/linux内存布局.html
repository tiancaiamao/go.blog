<h2>内存布局</h2><p>栈
堆
数据段
代码段</p><p>从低地址往高地址依次是：代码段-&gt;数据段-&gt;堆-&gt;栈</p><p>mmap的地址空间是位于堆与栈之间的</p><h2>malloc的实现</h2><p>malloc的实现是调用brk或mmap</p><p>若分配小于128K的内存，则调用brk</p><p>数据段最上面有个edata指针，brk会将edata指针往上推&apos; 回收的时候是回收到malloc库的内存池，不会归还系统</p><p>brk分配的只是虚拟地址，当访问相应内存时会发生缺页中断分配物理地址</p><p>若分配的内存大于128K，则由mmap在栈和堆之间分配一块内存</p><h2>测试</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/mman.h&gt;

int global;
int main() {
        int stack;
        void *heap;
        void *mmaped;
        int fd;

        fd = open(&quot;aaa&quot;, O_RDWR|O_CREAT|O_TRUNC);
        if(fd == -1) {
                perror(&quot;open&quot;);
                goto open_error;
        }
        if(lseek(fd, 23, SEEK_SET) == -1) {
                perror(&quot;lseek&quot;);
        if(lseek(fd, 23, SEEK_SET) == -1) {
                perror(&quot;lseek&quot;);
                goto lseek_error;
        }
        if(write(fd, &quot;&quot;, 1) != 1) {
                perror(&quot;write&quot;);
                goto lseek_error;
        }
        heap = malloc(34);
        mmaped = mmap(NULL, 22, PROT_WRITE, MAP_SHARED, fd, 0);
        if(mmaped == MAP_FAILED) {
                perror(&quot;mmap error&quot;);
                goto wrong;
        }
        printf(&quot;data: %p&apos;nstack: %p&apos;ncode: %p&apos;nheap: %p&apos;nmmap: %p&apos;n&quot;,
               &amp;global,
               &amp;stack,
               main,
               heap,
               mmaped);
        free(heap);
               mmaped);
        free(heap);
        return 0;
wrong:
        free(heap);
lseek_error:
        close(fd);
open_error:
        exit(-1);
}
</code></pre><p>写了个简单的代码测试了一下各个数据在内存区域的分布，运行结果如下：</p><pre><code>data: 0x804a040
stack: 0xbfea2ddc
code: 0x80485b4
heap: 0x9c12008
mmap: 0xb7748000
</code></pre>