<p>以前学数据结构，老师给我们讲带头结点的单链表和不带头结点的单链表。</p><p>对普通链表(不带头结点单链表)的操作，比如做删除或者插入，需要考虑一些特殊场景：1.判断是否空链表；2.操作头结点跟其它不一样，因为可能会修改head指针</p><pre><code>struct ListNode* list_delete1(struct ListNode *l, int n) {
  if (l == NULL) return NULL;
  if (l-&gt;val == n) {
    return l-&gt;next;
  }
  struct ListNode *prev = l;
  struct ListNode *cur = l-&gt;next;
  while(cur) {
    if (cur-&gt;val == n) {
      prev-&gt;next = cur-&gt;next;
      return l;
    }
    prev = cur;
    cur = cur-&gt;next;
  }
  return l;
}
</code></pre><p>带头结点的链表浪费一个结点的空间，换来的是代码的简化，因为不需要对头结点特殊考虑，所有操作都是一致的。</p><p>自己想到的一个小技巧，有些场合可以伪造一个fake的头结点出来，简化代码。</p><pre><code>struct ListNode* list_delete2(struct ListNode *l, int n) {
  struct ListNode fake;
  fake.next = l;
  for (struct ListNode *prev=&amp;fake; prev-&gt;next; prev=prev-&gt;next) {
    if (prev-&gt;next-&gt;val == n) {
      prev-&gt;next = prev-&gt;next-&gt;next;
      break;
    }
  }
  return fake.next;
}
</code></pre><p>下面的代码是不是比上面精简了？这个技巧在平时写代码或者是<a href="https://github.com/tiancaiamao/leetcode/blob/master/147.c#L22">刷题什么的</a>都可以用到。</p>