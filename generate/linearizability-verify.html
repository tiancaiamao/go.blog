<p>如何证明一个系统是可线性的？这个很难。有个相对简单的做法叫model check，意思是定义一个模型，假设系统是可线性化的，那么它的行为一定满足这个模型（但满足这个模型不一定是可线性化的，是必要非充分条件）。</p><p>看一个简单的例子。假设有一个变量A，两个client访问，将访问历史表示成这样子：</p><pre><code>[{Process: 2, Type: Invoke, F: Write, Value: 9}
{Process: 1, Type: OK, F: Write, Value: 4}
{Process: 1, Type: Invoke, F: Read, Value: 9}
{Process: 1, Type: OK, F: Read, Value: 4}]
</code></pre><p>Process是执行操作的client，Type类型可以是Invoke和OK，分别表示发起请求和请求完成。F表示调用的操作，Value是操作的参数。</p><p>接下来是模型的定义。Model中保存了自己的状态，在Step函数中，当它接受一个操作后，将转化为另一个状态，返回布尔值表示这一步是否可线性化：</p><pre><code>type Model interface {
    Step(op OP) bool
}
</code></pre><p>我们来实现一个Register模型。它有一个当前值，如果操作是读，仅当操作读到的值等于Register模型中保存的当前值时，它是合法的；如果操作是写，则用写入的值覆盖当前值。这很好理解，我们类比一下多个线程修改一个寄存器，假设线程间交错的执行次序产生的结果，等价于它们接某个依次串行执行的次序，那这个模型肯定不会发生上一步写了一个3，下一步读出一个4这种事情。</p><pre><code>type Register int
func (r *Register) Step(op OP) bool {
    if op.Type == OK &amp;&amp; op.F = Read &amp;&amp; op.Value != *r {
        return false
    }
    if op.Type == Invoke &amp;&amp; op.F = Write {
        *r = op.Value
    }
    return true
}
</code></pre><p>然后就可以用我们定义的模型来跑一遍历史，检查这个历史是否满足模型。如果不满足，那系统一定不是可线性化的。</p><hr /><p>剩下的问题就转化成了验证一串访问历史是否满足可线性化。</p><p>但是我们忽略了一个问题，(Invoke，OK)是一个pair，假设history中有两个Invoke操作：</p><pre><code>[a b]
</code></pre><p>实际可能发生的情况是</p><pre><code>[]
[a]
[b]
[a b]
[b a]
</code></pre><p>也就是说：可能a和b都没执行[]；只有a执行了[a]；只有b执行了[b]；a和b都执行了，顺序是先a后b[a b]；a和b都执行了，先b后a[b a]。</p><p>只要检查到某一个序列去跑我们的model能够通过，我们就算这个历史通过了：用最简单的暴力搜索，可以把所有的排列都计算出来，一个个再验证。但是当处于Invoke中的操作数稍大以后，整个可能的状态数就爆炸了。算一下20的阶乘，就发现这个数字大得不敢想象。</p><p>怎么办？有个online的算法，不是一口气把所有组合都算出来了再进行验证，而是一边计算可能的状态，一边做剪枝。[a b c]的全排列：</p><pre><code>[]
[a] [b] [c]
[a b] [b a] [a c] [c a] [b c] [c b]
[a b c] [a c b] [b a c] [b c a] [c a b] [c b a]
</code></pre><p>基于这样一个观察，如果[b a]已经是不可能的，那么我们根本不用测试[b a c]，所有以[b a]开头的都可以剪枝！</p><p>遇到Invoke，在当前状态上生成新的可能状态。遇到OK，则进行剪枝。检测所有当前状态，去掉不满足的。这样就要以让算法more reasonable了。剩下是一些工程上的东西，只要计算一个满足条件的解，可以用深度优先。需要搜索的解空间很大，可以挖掘一下多线程。</p><hr /><p>很久之前研究了一下的东西，当时因为优先级不在这个事情上。后面热情退一点没把代码写完，就不show链接了。想想还是值得说一下原理，便写了这篇博客。</p>