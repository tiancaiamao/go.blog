<pre><code>(define member
  _ [] -&gt; false
  X [X | _] -&gt; true
  X [_ | Y] -&gt; (member X Y))
</code></pre><p>第一步，将所有链表转成cons形式，将所有通配符转成唯一的变量</p><pre><code>(define member
  V [] -&gt; false
  X (cons X W) -&gt; true
  X (cons Z Y) -&gt; (member X Y))
</code></pre><p>第二步，确认所有规则都是left linear的，left linear是指箭头左边不会包含两个相同的变量。</p><p>如果不满足，可以通过一个替换实现</p><pre><code>(define member
  V [] -&gt; false
  X (cons U W) -&gt; true where (= U X)
  X (cons Z Y) -&gt; (member X Y))
</code></pre><p>第三步，计算函数参数个数n，确保所有规则参数个数是一致的。</p><pre><code>member = (/. A (/. B 
  (V [] -&gt; false
  X (cons U W) -&gt; true where (= U X)
  X (cons Z Y) -&gt; (member X Y))))
</code></pre><p>第四步是将各个独立的规则替换成一个使用模式匹配的lambda表达式。常规的lambda表达式只包含一个变量，而模式匹配lambda表达式中可以是symbol,variable,string,number,boolean,character，或者是空链表，一个tuple，或者由模式组成的cons表达式。</p><pre><code>(/. X X)
(/. (cons 1 []) 2)
</code></pre><p>前者是一个标准的lambda表达式，而后者是模式匹配的lambda表达式。</p><pre><code>(/. (cons 1 []) 2)	这个函数如果接受的输入是(cons 1 [])则返回2
(/. 1 2)			这个函数如果接受的输入是1则返回2
(/. [] [])		 	这个函数如果接受的输入是[]则返回[]
(/. (cons X []) X)	这个函数接受一个单元素的链表，并返回链表第一个元素
</code></pre><p>对于之前的例子，规则</p><pre><code>V [] -&gt; false
X (cons U W) -&gt; true where (= U X)
X (cons Z Y) -&gt; (member X Y)
</code></pre><p>分别变为</p><pre><code>(/. V (/. [] false))
(/. X (/. (cons U W) (where (= u X) true)))
(/. X (/. (cons Z Y) (member X Y)))
</code></pre><p>第五步，应用函数的参数，得到case表达式</p><pre><code>(/. A (/. B
  (cases
    (((/. V (/. [] false)) A) B)
    (((/. X (/. (cons U W) (where (= u X) true))) A) B)
    (((/. X (/. (cons Z Y) (member X Y))) A) B))))
</code></pre><p>cases的语义是在它的作用域内依次对各个表达式求值，遇到首个成功就返回。如果所有表达式都返回失败，则返回失败，表示匹配不到。</p><p>最后，包装到一个Y组合子里面</p><pre><code>(Y (/. M (/. A (/. B
  (cases
        (((/. V (/. [] false)) A) B)
        (((/. X (/. (cons U W) (where (= u X) true))) A) B)
        (((/. X (/. (cons Z Y) (M X Y))) A) B))))))
</code></pre><p>如何处理相互递归呢？</p><pre><code>(define even?
   {number --&gt; boolean}
   1 -&gt; false
   X -&gt; (odd? (- X 1)))
(define odd?
   {number --&gt; boolean}
   1 -&gt; true
   X -&gt; (even? (- X 1)))
</code></pre><p>先分别转化它们：</p><pre><code>(/. A (cases ((/. 1 false) A)
            ((/. X (odd? (- X 1))) A)))
(/. A (cases ((/. 1 true) A)
            ((/. X (even? (- X 1))) A)))
</code></pre><p>然后放到一个tuple里面</p><pre><code>(@p (/. A (cases ((/. 1 false) A)
                ((/. X (odd? (- X 1))) A)))
    (/. A (cases ((/. 1 true) A)
                ((/. X (even? (- X 1))) A))))
</code></pre><p>然后将递归函数调用转换成tuple里面的位置</p><pre><code>(@p (/. A (cases ((/. 1 false) A)
                ((/. X ((snd T) (- X 1))) A)))
    (/. A (cases ((/. 1 true) A)
                ((/. X ((fst T) (- X 1))) A))))
</code></pre><p>最后放到Y组合子里面</p><pre><code>(Y (/. T (@p (/. A (cases ((/. 1 false) A)
                    ((/. X ((snd T) (- X 1))) A)))
              (/. A (cases ((/. 1 true) A)
                          ((/. X ((fst T) (- X 1))) A))))))
</code></pre>