<p>遇到这个问题是这样的，<code>select * from t where a &lt; 5 and a &gt; 5</code> 我期望它能直接推导出来，这是一个空集，因为 <code>a &lt; 5 and a &gt; 5</code> 恒为假。结果呢？它给我搞出来了一个全表扫！这不就傻逼了。</p><p>嗯，扫了一眼我们的代码，开始没看太懂。于是决定自己想想怎么做。比如我们有下面这一系列的条件：</p><p>[= a 1] [= a c] [&gt; b c] [= b d] [&gt; c d] [= d f]</p><p>那么我们需要做的是，把 <code>a = 1</code> 这个常量表达式，不停地拿到集合里面去做替换，替换过程中，如果有新的常量表达式生成，可以记录下来。<code>[= a c]</code> 这个替换掉之后，就会生成一个 <code>c = 1</code>，继续用它执行下去，可以得出 <code>[&gt; b 1]</code> 和 <code>[&gt; 1 d]</code>，像 <code>[= d f]</code> 这种消除不掉的，就继续保留下来。</p><p>那么这个算法的基本框架是这样子的，已知的常量表达式 <code>[= a 1]</code> 这种，放到一个叫做 <code>Rules</code> 的集合里面，而未知的待替换的集合，我们叫 <code>Input</code>，拿 <code>Rules</code> 里面的每一条，去 <code>Input</code> 里面做替换，过程中如果有新的 <code>Rule</code> 生成，则放到 <code>Rules</code> 集合里面。直到 <code>Rules</code> 集合的所有规则都使用过了，没有更多的替换时，算法结束。</p><p>为了体现 lisp 的优越性，我决定用 shen 语言写写这段代码（装个逼）。</p><pre><code>(define constant-propagate0
        [] Input -&gt; Input
        [Rule | Rules] Input -&gt; (let Pair (apply-subst Rule Input [] Rules)
                                    Output (hd Pair)
                                    Rules (tl Pair)
                                    (constant-propagate0 Rules Output)))
</code></pre><p>这是一个递归函数。第一行，如果 <code>Rules</code> 为空了，算法就结束了。第二行，取第一条 Rule，将它应用到 <code>Input</code> 集合所有成员 <code>(apply-subst Rule Input [] Rules)</code>，它会生成新的 Rules 和新的输入（这里叫 <code>Output</code> 了），递归继续做 <code>constant-propagate0</code>。</p><pre><code>(define apply-subst
    Rule [] Output Rules -&gt;  (cons [Rule | Output] Rules)
    [= Var Const] [[= Var Var2] | Input] Output Rules -&gt;
          (apply-subst [= Var Const] Input Output [[= Var2 Const] | Rules])
    [= Var Const] [[= Var1 Var] | Input] Output Rules -&gt;
          (apply-subst [= Var Const] Input Output [[= Var1 Const] | Rules])
    [= Var Const] [[OP Var Var2] | Input] Output Rules -&gt;
          (apply-subst [= Var Const] Input [[OP Const Var2] | Output] Rules)
    [= Var Const] [[OP Var1 Var] | Input] Output Rules -&gt;
          (apply-subst [= Var Const] Input [[OP Var1 Const] | Output] Rules)
    Rule [H | Input] Output Rules -&gt; (apply-subst Rule Input [H | Output] Rules))
</code></pre><p><code>apply-subst Rule Input</code> 函数，第三个第四个参数，<code>Output</code> 和 <code>Rules</code> 是为了尾递归才写成这样的，它做的事情就是用 Rule 去跟 Input 里面的各个比较，新的结果会放到 <code>Output</code>，如果有新规则生成会放到 <code>Rules</code>。</p><p>好了，在 <a href="http://www.shenlanguage.org/">shen 语言</a> 里面（随便找个实现，比如 <a href="https://github.com/tiancaiamao/shen-go">shen-go</a>），敲进去这两函数，然而执行</p><pre><code>(constant-propagate0 [[= a 1]] [[= a c] [&gt; b c] [= b d] [&gt; c d] [= d f]])
</code></pre><p>会得到</p><pre><code>[[= c 1] [&gt; b 1] [= b d] [&gt; 1 d] [= d f] [= a 1]]
</code></pre><p>其实这个算法是借鉴类型推导里面，一个叫做算法W 的做法，简化的版本（好吧，我根本不知道常量传播标准做法应该是怎么做的）。</p><p>有几个问题，这里只处理了 <code>var = const</code> 这种表达式的推导，这是最简单的情况。其实归纳下来有好几种更复杂的场景。</p><p><code>var1 = var2</code> 和 <code>var &gt; const</code></p><p>这种情况其实不难，继续套用上面的算法框架仍然是能够处理的。比如我们只把 <code>var &gt; const</code> 这一类，作为 <code>Rules</code> 集合，把 <code>var1 = var2</code> 当作 <code>Input</code> 集合，拿规则集里面每条规则，过一遍 Input，就可以推导出更准确的 var 范围。</p><p>像之前的 [= a b] [= b c] [&gt; a 5] [&lt; c 3] ，先从 <code>Rules</code> 里面取出 [&gt; a 5]，将它应用到 [= a b] 上面，推出 [&gt; b 5]，新的 [&gt; b 5] 被加到 <code>Rules</code> 里面，再应用它到 [= b c] 时，会推出 [&gt; c 5]，丢到 <code>Rules</code> 里面... 最后规则里面会出现矛盾 [&lt; c 3] [&gt; c 5]，这种场景我们就可以判定 false 了。</p><p>比较难处理的，是 <code>var1 &gt; var2</code> 这种场景的推导。当 <code>var &gt; const</code> 作用于它时，结果不那么直观。比如 <code>a &gt; b</code>并且 <code>a &gt; 3</code> ，这个得不出啥信息。但 <code>a &gt; b</code> <code>b &gt; 3</code>，这个可以推出 <code>a &gt; 3</code>。也是可以丢到规则集里面继续利用的。主要麻烦在场景复杂了一些。</p><p>目前就想到这些吧。说说一个同事的脑洞。</p><ol><li><p>如果把所有等号两边的点，都当做图上面的节点，然而 <code>a &lt; b</code> 就构造一条从 a 到 b 的有向边。比如 <code>[&lt; a b]</code> <code>[&gt; a 5]</code> <code>[&lt; b 4]</code>，会构造出 <code>a -&gt; b</code> <code>b -&gt; 4</code> <code>5 -&gt; a</code>，如果我们再手动用 <code>[&lt; 4 5]</code> 构造一条，<code>4 -&gt; 5</code>，那么这个图就会成环了。也就是说，通过这样子构造一个图，然后检测成环，可以判断表达式是否是恒假的。</p></li><li><p>如果出现更复杂的 <code>a - b &lt; 3</code> <code>b - c &lt; 5</code> 这种表达式，两者相加可以推出 <code>a - c &lt; 8</code>。继续假想一个图，从 a 到 b 画一条出边，边的权值为 3，含义就是 a 到 b 节点的距离最少是 3。然后 b 到 c 画一条出边，边的权值为 5。把所有这种表达式都构造成图，那么求任意两节点之间的最短路径，就是两个变量的差值。比如 a 到 c 最短路径是 8,就是 <code>a - c &lt; 8</code>。如果再把常量引入，有可能把各变量的一些范围信息推出来。</p></li></ol><p>暂时还没有更多的想法，这哥们好喜欢图。好晚，不知道自己在想啥了，明天先好好改代码 bug 吧，不脑洞，实用为主。</p>