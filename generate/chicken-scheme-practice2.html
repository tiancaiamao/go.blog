<p><a href="chicken-scheme-practice.md">接上篇</a>，这次练习，我把自己的技术博客（本网站）用scheme重写了！</p><h2>web框架</h2><p>chicken提供了许许多多的eggs，相当于其它语言中的标准库或者三方库。我使用了<a href="http://wiki.call-cc.org/eggref/4/spiffy">spiffy</a>这个egg作为这个网站的web框架。</p><p>使用spiffy很容易，最简单的例子：</p><pre><code><class>language-scheme</class><@ />(use spiffy)
(root-path &quot;/var/www&quot;)
(server-port 8088)
(start-server)
</code></pre><p>root-path是静态的网站文件，可以打开本地的8080访问。</p><p>这个博客文件是用 markdown 写的，还有 rss 输出之类的东西，并不是完全静态的，所以还得做一些工作，首先是路由。</p><h3>router</h3><p>spiffy的路由是用一个动态变量vhost-map来决定的。有一张表，前面的参数是正则式，后面的参数是具体的handler函数。我把整个路由都自己接管了，所以直接匹配.*的正则。</p><pre><code><class>language-scheme</class><@ />(vhost-map `((&quot;.*&quot; . ,router)))
</code></pre><p>接下来我可以在router中做自己的派发。规则很简单，主要的博客文章都是用markdown写的，文件名是以.md结尾。有一些旧版的文件是用emacs的org-mode生成的html。还有一些以前用Go的present格式写的文件我已经手动改成markdown格式了。为不同的文件格式做不同的处理，各自有自己的handler。</p><h3>handler</h3><p>handler是一个类似如下形式的函数</p><pre><code>(define router
    (lambda (continue)
    ...))
</code></pre><p>注意到参数中除了continue什么都没有，如何拿到request，如果返回response呢？</p><p>其实是用动态绑定实现的。在handler中，这些动态绑定的变量都是可用的，比如：</p><pre><code>(current-request)
</code></pre><p>这样就可以拿到request信息了，包括请求的路径，请求的参数等等。</p><pre><code>(send-response :body body)
</code></pre><p>这样子，基本的web处理的功能就都有了。</p><h2>内容处理</h2><h3>sxml做模板</h3><p>要说用scheme写web有什么优势，绝对得拿sxml说事！我们看两段代码：</p><pre><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
    xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
    &lt;head&gt;
    &lt;title&gt;An example page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1 id=&quot;greeting&quot;&gt;Hi, there!&lt;/h1&gt;
        &lt;p&gt;This is just an &amp;gt;&amp;gt;example&amp;lt;&amp;lt; to show XHTML &amp;amp; SXML.&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>再看这段代码：</p><pre><code>(html (@ (xmlns &quot;http://www.w3.org/1999/xhtml&quot;)
    (xml:lang &quot;en&quot;) (lang &quot;en&quot;))
    (head
    (title &quot;An example page&quot;))
    (body
        (h1 (@ (id &quot;greeting&quot;)) &quot;Hi, there&quot;)
        (p &quot;This is just an &gt;&gt;example&lt;&lt; to show XHTML &amp; SXML.&quot;)))
</code></pre><p>两者是完全等价表示！得益于scheme对s表达式强大的操作能力，sxml写模板非常的自然。</p><p>从sxml生成html，我使用了<a href="http://wiki.call-cc.org/eggref/4/sxml-transforms">sxml-transforms</a>这个egg。</p><h3>markdown解析</h3><p>现在有了路由，有了handler，有了sxml的模板，我需要把markdown格式的文章填充进来。</p><p>嗯，解析markdown生成sxml，也有相应的egg可以实现，<a href="http://wiki.call-cc.org/eggref/4/lowdown">lowdown</a>就是这样一个库。</p><p>注意用lowdown的时候还有一点点小问题，它默认是英文字符集的，不支持中文输出。所以我改了一下源代码，加个utf8支持。</p><h3>atom</h3><p>为了输出rss订阅，我又去找了一个生成atom的包，这个egg直接就叫做<a href="http://wiki.call-cc.org/eggref/4/atom">atom</a>。</p><hr /><p>之前一直偷懒，这次重写顺带把评论的功能加上去了，disqus做的。</p><p>还有运维方面一些变化，之前 Go 版本的博客是托管在 heroku 上面的，每次 git push 代码，那边会自动重新编译，重启。这次打算丢到自己的 vps 上面去，一直是 markdown 格式来写博客，直接 git push 的方式发布。现在没有推代码自动重编译了，没有重启和重新加载数据，所以呢，就改改代码周期性的读文件重建索引吧。</p><h2>结语</h2><p>chicken scheme 确实是一个非常不错的 scheme 的实现，它的实现方式非常 hack-friendly，而且周边的生态都很好，库也很丰富。</p><p>这次拿它来重写博客练手，也算是用 scheme 语言做一些“实际”的东西吧。</p><p>代码还是在 <a href="https://github.com/tiancaiamao/go.blog">https://github.com/tiancaiamao/go.blog</a></p><p>哦，下次我想做一个 web 的性能测试，对比一下 Go 和 chicken scheme 谁更高一些。</p>