<p><a href="./go-http-middleware.md">上篇文章</a>中提到了一下这个问题，但我之前只是写“直觉上认为”，并且还不解释。因为我了解Go的底层，知道方法和闭包分别是怎么实现的，然后用直觉做的判断。但是事后觉得写博客不能这么不严谨，所以做了个测试。</p><p>结论大致是对的，但结果也有一些出乎之间意料的地方。</p><p>假设我们要实现下面这个接口：</p><pre><code>type I interface {
    XXX()
}
</code></pre><p>分别用闭包和对象的方式实现。闭包或是对象，在这里都是想封装一些状态。用对象的写法：</p><pre><code>type Object struct {
    A int
}

func (obj *Object) XXX() {
    obj.A++
}
</code></pre><p>用闭包的写法：</p><pre><code>func Closure() func() {
    var A int
    return func() {
        A++
    }
}
</code></pre><p>为了实现接口I，闭包写法需要一点辅助：</p><pre><code>type IFunc func()

func (f IFunc) XXX() {
    f()
}
</code></pre><p>现在测试：</p><pre><code>var (
    obj I
    clo I
)

obj = &amp;Object{}
clo = IFunc(Closure())

for i := 0; i &lt; 10000000; i++ {
    obj.XXX()
}
for i := 0; i &lt; 10000000; i++ {
    clo.XXX()
}
</code></pre><p>在我的机器上得到的结果：</p><pre><code>object: 30.026664ms
closure: 54.920985ms
</code></pre><p>所以说结论大致是对的。</p><hr /><p>我又测试了一下直接调用Object.XXX()跟Closure()()，两者性能其实没差异。主要问题是在闭包写法多了一层转换步骤，直觉地认为闭包比方法慢是有偏见的。这是我所说的有点出乎意料的地方。</p><p>Go语言中，方法在<a href="https://github.com/tiancaiamao/go-internals">底层的实现</a>，实际上就是普通函数多加了一个参数，将对象作为这个参数。比如上面的</p><pre><code>func (obj *Object) XXX() {
    obj.A++
}
</code></pre><p>变换为底层的处理就是</p><pre><code>func XXX(obj *Object) {
    obj.A++
}
</code></pre><p>至于闭包，则是会将一个函数指针和各个upvalue打包到一起。</p><pre><code>func Closure() func() {
    var A int
    return func() {
        A++
    }
}
</code></pre><p>转化之后等价于</p><pre><code>func fun001(A *int) {
    (*A)++
}
func Closure() struct {
    return &amp;struct{
        fun001,
        new(int),
    }
}
</code></pre><p>应该说，性能上真的没有差异。可能对象写法比闭包写法对内存更友好一点点。</p><p>如果用两种方式都可以实现时，到底是选对象还是闭包呢？如果纠结的话，我还是更推荐对象写法一些。如果不纠结的话，都可以，无所谓。</p>