<p>在 scheme 语言里面，有个 let loop 宏：</p><pre><code>(let Label ((Var Init) ...) Body)
</code></pre><p>比如说从 1 加到 100</p><pre><code>(let loop ((n 1) (sum 0))
    (if (= n 100)
        sum
        (loop (+ n 1) (+ sum n))))
</code></pre><p>在 cora 语言里面，我想引入一个通用的宏用于写循环，不过 <code>let</code> 这个 syntax 已经被占用了，所以就叫 <code>let-loop</code> 吧。我想这样写：</p><pre><code>(let-loop recur (n 0 sum 0)
      (if (= n 100)
          sum
        (recur (+ n 1) (+ sum n))))
</code></pre><p>如果展开成这样子，会引入 <code>recur</code> 的定义，污染全局命名空间，我不想有这种副作用：</p><pre><code>((set 'recur (lambda (n sum)
           (if (= n 100)
           sum
         (recur (+ n 1) (+ sum n)))))

 0 100)
</code></pre><p>第一版，错误的实现</p><pre><code>((let recur (gensym 'tmp)
     (set recur (lambda (n sum)
          (if (= n 100)
              sum
            (recur (+ n 1) (+ sum n))))))
 0 100)
</code></pre><p>如果展开成这样子，lambda 函数里面的 recur 其实是一个 symbol 而不是一个 function，所以会出错。</p><p>按照 scheme 的搞法，应该用 <code>letrec</code>，或者是 <code>set!</code> 去改变量的值。</p><pre><code>(lambda ()
    (define recur (void))
    (define fn (lambda (n sum)
                 (if (= n 100)
                     sum
                     (recur (+ n 1) (+ sum n)))))
    (set! recur fn)) 
</code></pre><p>cora 的 <code>set</code> 其实跟 scheme 的 <code>set!</code> 是不一样的语义。在 cora 中 <code>set</code> 是设计成一个函数的，它就是给一个 symbol 绑定一个值。哪怕这样写：</p><pre><code>(lambda (f)
    (set f xxx))
</code></pre><p>在 cora 中整个语义是：f 的值，必须是一个符号，然后调用函数把这个符号的值设置为 xxx。在 scheme 中 <code>set!</code> 是可以重新绑定变量的。cora 更加&quot;纯&quot;函数一些，没有这种副作用，变量不能改。</p><p>第二版，正确，但是丑。</p><pre><code>(let recur (gensym 'tmp)
     (set recur (lambda (n sum)
          (if (= n 100)
              sum
            ((value recur) (+ n 1) (+ sum n))))))
</code></pre><p>想了一个方法是，弄个 value 函数从 <code>recur</code> 这个符号得到对应的值，这样就可以了。然而写代码总是有点不太爽，因为不能直接 <code>recur</code> 而是 <code>(value recur)</code> 感觉怪怪的。</p><p>由于 cora 不能用 set 把方式搞，只能想其它办法。比如，Y 组合子：</p><pre><code>(Y (lambda (recur)
    (lambda (n sum)
        (if (= n 100)
            sum
            (recur (+ n 1) (+ sum n))))))
</code></pre><p>但是 Y 组合子有一个问题，是 cora 不是 lazy evaulation 的，因此要走一个 eta 变换 (alpha, beta, eta ...)，否则会死循环。</p><p><code>(f f)</code> =&gt; <code>(lambda (x) ((f f) x))</code></p><p>走 eta 变换这里又会遇到变参函数问题。有可能需要不一样的参数数量：</p><p><code>(f f)</code> =&gt; <code>(lambda (x y) ((f f) x y))</code></p><p>在 scheme 里面处理方式是用的 apply，这个是可以支持可变参数的：</p><p><code>(f f)</code> =&gt; <code>(lambda a (apply (f f) a))</code></p><p>回到 Y 组合子的推导过程，我发现 let loop 宏在 cora 里面还是可以实现的。</p><pre><code>(lambda (recur)
    (lambda (n sum)
        (if (= n 100)
            sum
            ((recur recur) (+ n 1) (+ sum n)))))
</code></pre><p>注意不再是 recur，而是 <code>(recur recur)</code>，因为 recur 是接受一个函数才返回 <code>(lambda (n sum) ...)</code>，接受的函数是它自己。</p><p>再叫 <code>recur</code> 不太准确，做个 alpha 变换，改叫 <code>meta</code></p><pre><code>(lambda (meta)
    (lambda (n sum)
        (if (= n 100)
            sum
            ((meta meta) (+ n 1) (+ sum n)))))
</code></pre><p>cora 是自动做 curry 的，函数定义可以写到一起 <code>(lambda (meta n sum) ...)</code>, 再把 <code>(meta meta)</code> 提取出来，叫 <code>recur</code></p><p>最终版本</p><pre><code>(let f (lambda (meta n sum)
      (let recur (meta meta)
           (if (= n 100)
           sum
         (recur (+ n 1) (+ sum n)))))
     (f f))
</code></pre>