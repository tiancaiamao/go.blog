<p>Essential of Programming Language简称EOPL，名字听上去就非常霸气。第一次听到作者Dan FredMan的大名是从王垠那里，他专门写过一篇文章讲导师Dan Fredman，并称他是世界上最懂编程语言的人，你永远不知道他的极限在哪里。大师出的作品肯定是masterpiece啦！</p><p>言归正传。</p><p>前面是讲基础概念的。编译，解释器等基本知识。书中说“The interpreter for a computer language is just another program”。我很喜欢这句话，因为我顿悟时领悟到的就是：解释/编译器只不过是一个函数，它接受一个string，输出另一个函数。如果你能理解我所说的，那么你的境界已经很高了。</p><p>第一章是递归，基本上scheme相关的书都从基本的递归函数开始。有些像添加额外参数定义辅助函数的技巧还是很重要的，重要性不亚于SICP中定义递归函数时寻找“不动点”。作者的行文安排是很注意前后相承的，在最前面就故意拿occures-free这些函数作为例子，其实是后面章节中解释、编译器需要用到的基本函数。</p><p>第二章讲数据抽象，跟SICP讲数据抽象部分的内容差不多。只要满足一组函数定义，也就是满足某个接口，它就是一种抽象数据。前两章基本上都是关于递归的，把函数递归，数据递归都包括了。</p><p>从第三章开始设计自己的语言。从简单到复杂，开始只有加减的语言，到有Procedure，引入了环境，LET并讲了作用域和绑定相关的概念，在scheme语言中理解作用域是非常重要的。</p><p>第四章讲状态和副作用。关于副作用方面讲得不如SICP深刻，不过应该说EOPL在这一章中更为强调的是存储的概念，讲了隐式引用和显示引用。把scheme和elisp拿着比较，就很容易明白作者在讲什么。符号是引用的一个存储位置，而存储位置存放的东西就是符号的值。elisp中显示引用的，从setq就可以看出来，它是可以(set (quote var) val)的。而scheme就是隐式引用，不会暴露存储这一层给用户。也提了一下lazy-evaluateion，惰性求值中求值顺序是很不确定的，而在有副作用的情况下这种顺序不确定影响非常大，因此一般在函数式语言中才会支持惰性求值。</p><p>scheme的关键字很少，但每添加一个关键字都让语言从本质上发生变化。如果没有lambda，没有环境，那么基于替换的求值模型就是可以的。引用环境之后就变成了带环境的求值模型。再比如说如果没有set!，没有赋值就没了副作用，状态不会改变。</p><p>第五章是带continuation的解析器，跟lisp in small pieces中那章基本上是一样的。&quot;蹦床&quot;技术跟我以前看过的一篇论文差不多，在过程式语言中，每当进入一个新的procedure时会栈会增长一层，由于执行完之后连续绝不会返回，如果用过程式语言来实现这里的带连续的解析器就会出问题了。用连续实现异常机制也不是什么难以理解的事，连续是对执行过程的抽象，这货太强大了。比较令人震惊的是用它实现线程。开始觉得很不可思议，后面想想也正常了。加个调度器是很容易的事，实现用户级线程最麻烦的是保存上下文，然后支持连续的语言中，其实根本没有保存上下文一说，连续自身就包含了保存上下文！</p><p>第六章，CPS转换。关于CPS本身没什么好说的。书中后面部分是利用CPS转换，将副作用“显示”化，就像用连续把控制流给显示化一样。</p><p>后面几章就不想读了，关于类型推理，模块，对象系统。总体来讲第四章是个分支，四到五六章，或者四到七八九章。前六章完全是解释器方面的内容，所以跟lisp in small pieces重复度很高。这本书读得很快，都没有细看。</p>