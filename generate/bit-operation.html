<p>位运算操作某种程度上可以看出一点基本功，区分懂底层和不懂的人。</p><h2>先做个题</h2><p>现在假设有一个uint32，高16位是mask位，低16位是value位。这样，修改可以用一个uint32的值表示。</p><p>比如说，我用一个uint32的变量存一些状态位(其实只有低16位有效)，这个变量叫status。用另一个uint32变量存修改，这个变量叫change。</p><pre><code>status = 0x 00 00 00 02
change = 0x 00 09 00 01
</code></pre><p>意思是，对status进行修改，要把最后一位设置为1，把倒数第四位设置为0，如何执行这个位操作？</p><p>只使用到了4位，写简单一点，把change拆成mask和value来看：</p><pre><code>status = 0010
mask   = 1001
value  = 0001
</code></pre><p>第一步，status不在mask中的位是需要保留的，我们将它拿出来，通过对mask取反，再跟status做与运算：</p><pre><code>tmp1 = ~mask
tmp2 = status &amp; tmp1
</code></pre><p>第二步，status中mask对应的位是需要更新的为value的，我们将需要的更新从value中拿出来：</p><pre><code>tmp3 = value &amp; mask
</code></pre><p>第三步，将上面的两个结果合并，得到最终结果</p><pre><code>status = tmp1 | tmp2
</code></pre><p>ok.</p><p>这里是以4位来说明的，最初那个问题的也可以解出来了，要做一些移位，就不写了。也许用异或运算做还有更简单的方法。</p><h2>基本</h2><p>或运算用于置位，将第5位置为1:</p><pre><code>x | (1&lt;&lt;5)
</code></pre><p>与运算用于清位，将第5位清0:</p><pre><code>x &amp;= ~(1&lt;&lt;5)
</code></pre><h2>进阶</h2><p>判断一个数是否8的倍数(低3位全0)：</p><pre><code>x &amp; (1&lt;&lt;3) == 0
</code></pre><p>将一个数按8的倍数向上取整：</p><pre><code>x = (x+1) &amp; (1&lt;&lt;3)
</code></pre><p>判断一个数是否2的n次方，如2,4,8,16,32,64...：</p><pre><code>x &amp; (x-1) == 0
</code></pre><h2>来个高端的</h2><p>将一个32位的数，按位对称的反转，见<a href="./lockfree-hash.article">这里</a>。</p><p>玩得开心!</p><p>--------------2015.6.23更新-------------</p><p>再来一个判断一个机器是32位还是64位的方法：</p><p>(^0)&gt;&gt;63 如果等于1，说明是64位，如果等于0，说明是32位(假设现在机器不是64就是32)。</p><p>指针的占的大小可以用4 &lt;&lt; ((^0)&gt;&gt;63)</p>