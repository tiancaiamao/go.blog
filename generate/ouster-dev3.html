<p>这周回家了，回家，办宽带，报驾校，考科目一杂事做了好多，实际的有效工作时间居然也就两天的样子。好的一方面是开始慢慢进入状态了。之前一边写客户端一边写服务端，感觉效率太低了一点，于是决定先专心做服务端，做好测试和模拟，后面再去做客户端做联调。</p><p>这两天做的主要事情是：技能初步，怪物逻辑。</p><p>技能那边。一个技能释放出去之后，涉及的流程是：判断技能释放是否成功，计算技能产生的伤害，将技能效果广播到周围玩家。技能按释放目标分类，可以分为对地释放和对目标(怪物或玩家)释放，对自身使用的技能算是对目标释放的一种特殊形式。而按照效果分类，可以分为攻击/状态。我想把技能的计算尽量放到agent中，也就是负责玩家的goroutine中，这样可以减轻scene的heartbeat时的计算负担。agent将技能计算好之后，将效果发给scene，由scene再广播给周围玩家。对目标释放的技能可以这么做，但是对地释放的范围类技能，还是放到scene中会好一些。</p><p>计算技能效果是比较偏上层逻辑，暂时还没具体去策划各个技能。主要就是一些属性计算，自己的基础攻击，命中，敌人的闪避，防御。而像攻击，命中，闪避，防御这些都属于二次属性，是需要像力量，敏捷一类的基础属性，以及玩家身上的状态来计算得到的。公式计算这一块应该是计算量还算大的，放在不同goroutine中分摊开销。</p><p>怪物逻辑这边，以前玩的游戏的时候看到各种各样的表现形式，当时不懂，现在自己思考一下立马能推理出是怎么做的。比如怪物如果死盯着第一个它发现的敌人攻击，像神魔大陆中那样，那明显就是设计时偷懒，怪物的结构体上设定一个目标就不改了。天龙八部上好像也是的，偷懒的做法没有计算仇恨值，所以由比较T的职业去引怪，引完怪都盯着T打，奶到旁边加血，只要T不死，怪就不去打其它人。像剑三和WOW这一类明显就是做得更复杂的。</p><p>然后有的游戏中怪物会一直追玩家，而有的游戏中怪物追一段就回去出生地了。这个区别就是会回去的怪物是设定了一个活动区域的，出了活动区域就会脱离。至于脱离的情况，有的游戏中一旦脱离，怪物直接就满血了，而有的游戏中是怪物受伤后会慢慢回血，也有的游戏中是怪物受伤后一直就那个血量了。直接满血的做法，和一直保持血量的做法是更好一点的。云风大神提到过这一块的优化，由玩家接近怪物后，aoi模块来激活怪物，只有激活了的怪物会心跳，未激活的怪物不做心跳，这样可以节省计算开销。而如何要慢慢回血，就需要每次心跳时处理未激活的怪物了。</p><p>关于怪物的重生，目前地图信息中记录了两种出生信息，一种是Enemy，一种是EnemyGroup。前者是单个怪物，类型，坐标和活动范围等，而后者是一组怪物，记录了最多/最少数目，出生范围信息。怪物的结构体中有个是否死的的标志位，还有时间信息，如果死掉了，就隔一段时间后根据出生信息进行重生。</p><p>在scene中，对每个生物都有一个id编号，我用了一个uint32，用这个id可以获取对应的实体。为了区分玩家和npc，玩家的最高位是0，而npc最高位是1。scene中有几个数组，有记录玩家，有记录怪物，用id与mask做与运算之后，得到的下标去相应数组中查找就可以得到相应的实体。aoi模块中使用的编号也用这个id了。</p><p>好吧，继续代码吧。</p>